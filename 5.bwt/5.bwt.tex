\documentclass[letterpaper, 11pt]{article}

% set version variable
\newcommand{\versionnumber}{0.1}

% russian language
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english, russian]{babel}

% math
\usepackage{mathtools}
\usepackage{amsmath}

\usepackage{amssymb} % some math symbols
% abs function
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}

% enumerate
\usepackage{enumerate}

% set type and margins of the page
\usepackage{geometry}  % document margins
\geometry{letterpaper, left=1.4in, right = 1.4in, top = 1.7in, bottom = 1.7in}

% color links in content
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=red,
    urlcolor=blue,
    linktoc=all
}

% indent at first \par after section
\usepackage{indentfirst}

% fixed table and figures in section
\usepackage{float}

% colors
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}

% paragraph indent
\setlength{\parskip}{0.5em}

% pseudocode
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\title{\large{Краткий конспект}\\
\LARGE{Лекция 5. Преобразование Барроуза-Уилера}\\
\normalsize версия \versionnumber (\textcolor{NavyBlue}{draft})}
\date{28 марта, 2016}
\author{\underline{Д. Ищенко\thanks{МФТИ}} \and Б. Коварский\footnotemark[1]
\and И. Алтухов\footnotemark[1] \and Д. Алексеев\footnotemark[1]}

\begin{document}
\maketitle
\thispagestyle{empty}
\clearpage

% let's go
\section{Оценка памяти необходимой для хранения суффиксного дерева}

На предыдущей лекции мы обсуждали структуру суффиксного дерева и показали, что с помощью него можно решить задачу поиска $k$ мотивов длины $m$ в геноме за $O(km)$. Это очень <<хорошая>> временная сложность и, казалось, бы, что можно еще совершенстовать? Зайдем с другой стороны и оценим, какая память необходима для хранения суффиксного дерева? Мы показали, что для последовательности длины $n$, кол-во суффиксов, а значит и листьев в дереве $n$ штук. Каждый внутренний узел дерева, в результате ветвления от него, добавляет как минимум один \textit{новый} лист в дерево, т.е. внутренних листов в дереве не больше $n$. Таким образом всего в дереве не больше $2n$ узлов и, соответственно, ребер. Для каждой метки ребра нам нужно хранить 2 числа (начало и конец подпоследовательности в геноме), т.е. для хранения всех меток, нам потребуется $2n \cdot 2 = 4n$ чисел и сам геном длины $n$. В итоге, для хранения всего дерева нам потребуется $2n + 4n + n = 7n$ чисел, а это в семь раз больше, чем необходимо для хранения просто последовательности генома.

Например, в случае генома человека длиной $3\cdot10^9$ нуклеотидов, нам было бы необходимо выделить $3Gb \cdot 7 = 21Gb$ оперативной памяти, что, естественно, невозможно сделать на обыкновенном персональном компьютере. Можем ли мы решить эту проблему? Оказывается, что да. Есть несколько решений, например, одно из них -- это суффиксные массивы, мы же будем говорить сегодня о \textit{преобразованиях Барроуза-Уилера}. Но прежде, чем перейти непосредственно к преобразованию, разберемся, как мы можем компактно хранить информацию о строках.

\section{Сжатие данных}

Рассмотрим следующую строку длиной 34:
\begin{verbatim}
  AAAAAAAATTTTTTTGGGGGGGAAAAAAAACCCC
\end{verbatim}

Если хранить ее просто, как набор чисел, то нам потребуется 34 байта. Можем ли мы уменьшить это кол-во, не потеряв при этом информации? Можем:

\begin{verbatim}
  8A 7T 7G 8A 4C
\end{verbatim}

Такая краткая запись позволит нам хранить строку, используя всего 10 байт. Важно отметить, что взяв сокращенную запись строки, мы легко можем восстановить исходную. Собственно, этот пример и демонстрирует один из простейших вариантов сжатия данных. Но, что если мы возьмем следующую строку длиной в 8 символов:

\begin{verbatim}
  TATATAGA
\end{verbatim}

Применив вышеописанный подход, мы получим:

\begin{verbatim}
  1T 1A 1T 1A 1T 1A 1G 1A
\end{verbatim}

В этом случае, мы даже увеличили необходимую для хранения строки память. Конечно, мы могли бы заметить, что в строке идут повторяющиеся блоки TA и записать следующее:

\begin{verbatim}
  3TA 1GA
\end{verbatim}

Но каким образом находить все подобные повторяющиеся блоки? Сколько времени это займет? А как быть, если они идут не подряд? Как работать потом со сжатой таким образом строкой и искать в ней мотивы? Возникает много вопросов и ответом на них и решением задачи сжатия как раз и является преобразование Барроуза-Уилера.

\section{Преобразование Барроуза-Уилера}

Рассмотрим строку S = TATATAGA. Как и при рассмотрении суффиксных деревьев, добавим в конец исследуемой последовательности символ \$. И рассмотрим набор из всех циклических перестановок строки. Он будет иметь следующий вид:
\begin{verbatim}
  T A T A T A G A $
  A T A T A G A $ T
  T A T A G A $ T A
  A T A G A $ T A T
  T A G A $ T A T A
  A G A $ T A T A T
  G A $ T A T A T A
  A $ T A T A T A G
  $ T A T A T A G A
\end{verbatim}

Введем следующее свойтсво алфавита: $\$ < A < C < G < T$. Эта свойство позволяет нам сравнивать между собой символы и производить сортировку строк одинаковой длины. Например две строки ATG и ATA в осортированном порядке:

\begin{verbatim}
ATA
ATG
\end{verbatim}

Первые два символа у них совпадают, а третий $A < G$, поэтому строка ATA идет перед ATG.

Отсортируем все циклические перестановки строки S. Получим следующий набор строк (его можно представить матрицей $n \times n$).

\begin{verbatim}
  F               L
  
  $ T A T A T A G A
  A $ T A T A T A G
  A G A $ T A T A T
  A T A G A $ T A T
  A T A T A G A $ T
  G A $ T A T A T A
  T A G A $ T A T A
  T A T A G A $ T A
  T A T A T A G A $
\end{verbatim}

Назовем первый столбец матрицы -- \textbf{F} (<<first>>) и последний -- \textbf{L} (<<last>>). Очевидно, что первый столбец состоит из подряд идущих блоков состоящих из \$, A, C, G и T, т.к. по нему в первую очередь шла сортировка. Но куда интересней последний столбец \textbf{L} (на самом деле он и представляет из себя преобразование Барроуза-Уилера $BWT(S) = L$). В столбце \textbf{L} тоже встречаются подряд идущие символы, почему так происходит, если сортировка по нему шла в последнюю очередь (после сортировки по всем предыдущим символам)?

\section{Индексы Ферраджина-Манзини}
\section{Поиск мотива}
\section{Определение количества вхождений}
\section{Ссылки}

\begingroup
\renewcommand{\section}[2]{}%
\begin{thebibliography}{7}


\end{thebibliography}
\endgroup

\end{document}
