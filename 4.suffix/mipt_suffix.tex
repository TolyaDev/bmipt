\documentclass[letterpaper, 11pt]{article}

% set version variable
\newcommand{\versionnumber}{0.1}

% russian language
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english, russian]{babel}

% math
\usepackage{mathtools}
\usepackage{amsmath}

\usepackage{amssymb} % some math symbols
% abs function
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}

% enumerate
\usepackage{enumerate}

% set type and margins of the page
\usepackage{geometry}  % document margins
\geometry{letterpaper, left=1.4in, right = 1.4in, top = 1.7in, bottom = 1.7in}

% color links in content
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=red,
    urlcolor=blue,
    linktoc=all
}

% indent at first \par after section
\usepackage{indentfirst}

% fixed table and figures in section
\usepackage{float}

% colors
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}

% paragraph indent
\setlength{\parskip}{0.5em}

% pseudocode
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\title{\large{Краткий конспект}\\
\LARGE{Лекция 4. Суффиксные деревья}\\
\normalsize версия \versionnumber (\textcolor{NavyBlue}{draft})}
\date{7 марта, 2016}
\author{\underline{Д. Ищенко\thanks{МФТИ}} \and Б. Коварский\footnotemark[1]
\and И. Алтухов\footnotemark[1] \and Д. Алексеев\footnotemark[1]}

\begin{document}
\maketitle
\thispagestyle{empty}
\clearpage

% let's go
\section{Задача поиска k мотивов в геноме}

Вернемся к задаче поиска мотива $m$ в геноме $g$. В лекции о Z-алгоритме мы выяснили, что ее можно решить за линейное время $O(|m| + |g|)$, где $|m|$ - длина мотива, $|g|$ - длина генома. Представим, что необходимо найти $k$ различных мотивов в геноме $g$. Используя предыдущий метод, мы будем конструировать <<Z-ящики>> для каждой объединенной строки $m\$g$ и производить поиск. Соответственно временная сложность алгоритма вырастет до $O(k(|m| + |g|))$, в виду того, что $|m| \ll |g|$, сложность - $O(k|g|)$.

В реальных задачах $k$ может иметь достаточно большое значение, например, при картировании ридов (коротких последовательностей) на референсный геном, значения $k$ могут быть порядка $10^6 - 10^8$. Возникает необходимость оптимизации алгоритма. В этой лекции мы рассмотрим такую конструкцию, как суффиксное дерево и покажем, как с помощью него решить задачу поиска мотива и несколько других задач, существенно уменьшив временную сложность вычислений относительно Z-алгоритма.

\section{Cуффиксное дерево}

По аналогии с ранее введенными префиксами строки $S$ длиной $n$, назовем \textbf{$k$-ым суффиксом} строки $S$ ее подстроку, начинающуюся с $k$-го и заканчивающуюся последним символом: $S[k..n]$. Например, для строки TATATG все множетсво суффиксов будет представлять из себя:
\begin{verbatim}
1: TATATG
2: ATATG
3: TATG
4: ATG
5: TG
6: G
\end{verbatim}

Отметим, что количество всех суффиксов строки $S$ равно ее длине, а также тот факт, что полная строка также является суффиксом самой себя (первый суффикс).

Введем понятие \textit{суффиксного дерева}. В общем виде -- это \href{https://goo.gl/VwAiep}{древовидный граф} с набором вершин и ребер, создающийся из всех суффиксов последовательности $S$. В графе к каждому ребру приписана <<метка>>, соответствующая некоторой подстроке из $S$. Двигаясь по ребрам от выделенной вершины суффиксного дерева, называемой корнем, к одному из листьев дерева (вершине, к которой ведет только одно ребро) и соединяя последовально <<метки>> ребер в одну последовательность, в конечном итоге мы получаем один из суффиксов исходной последовательности $S$. Неформально процесс создания суффиксного дерева можно описать следующим образом:
\begin{enumerate}[(i)]
\item
допишем в конец последовательности $S$ символ, не встречающийся в самой последовательности, например: \textbf{\$}, тем самым получим последовательность $S^{*} = S\$$
\item
возьмем все суффиксы последовательности $S^{*}$, <<закрепим>> их начала в одной вершине, называемой корнем дерева (Рис. 1), в <<концы>> суффиксов поместим вершины и соединим их ребрами с корнем дерева. Вершины пронумеруем от $1$ до $n$, ребрам припишем <<метки>> равные соответствующим суффиксам, тем самым <<направив>> ребра от корня к листьям.

\begin{figure}[H]
  \center{
  \includegraphics[scale = 0.85]{fig/fig1.jpg}
  }
  \caption{Создание суффиксного дерева для последовательности $S$.}
\end{figure}

\item
<<склеим>> ребра с совпадающими началами, объединив их общую часть в одно ребро и <<ответвив>> от новой внутренней вершины несовпадающие части. Образованный граф представляет из себя суффиксное дерево для последовательности $S^*$.
\end{enumerate}

Отдельно стоит отметить, что суффиксное дерево -- <<направленный>> граф, т.е. по ребрам мы можем двигаться только в одном направлении. Из этого следует, что у корневого узла и внутренних узлов есть узлы-<<потомки>> (узлы, к которым можно прийти, двигаясь по направленным ребрам). А также у всех узлов, кроме корневого (внутренних и листьев) есть узлы-<<предки>> или <<родительские>> узлы (те, из которых приходим в эти узлы двигаясь по направленным ребрам). 

Перечислим некоторые свойства суффиксного дерева:
\begin{enumerate}[(i)]
\item
Количество листьев дерева равно количеству суффиксов последовательности $S^*$.
\item
Каждый узел в дереве, кроме корневого, имеет ровно один родительский узел.
\item
Двигаясь по ребрам от корня дерева к одному из \textit{листьев} и объединяя метки соответствующих ребер в одну последовательность, последняя будет соответствовать одному из \textit{суффиксов} последовательности $S^*$.
\item
Двигаясь по ребрам от корня дерева к одной из \textit{внутренних вершин} дерева и объединяя метки соответствующих ребер в одну последовательность, последняя будет соответствовать некоторой \textit{подстроке} из $S^*$.
\item
Для любой подстроки $S^*$ можно найти соответсвующий ей путь от корня дерева, причем, путь не обязательно завершается в вершине дерева, а может быть заверешен в середине одного из ребер.
\item
Метки ребер выходящих из корня или любой внутренней вершины отличаются первыми символами (иначе они были бы склеены в одно ребро). Следовательно из любой вершины не может выходить больше $\sigma + 1$ ребер, где $\sigma$ -- размер алфавита (количество разных символов, для нуклеотидной последовательности $\sigma = 4 + 1 = 5$ (добавляем дополнительный символ \$)).
\item
Если общее число вершин в дереве равно $N$, то число ребер: $(N - 1)$.

Предположим, что мы построили для последовательности $S$ суффиксное дерево, как с помощью него определить количество вхождений мотива $p$ в строку $S$?
\end{enumerate}

\clearpage
\section{Алгоритм построения $O(n^2)$}

Хранить суффиксное дерево можно различными способами, рассмотрим один из самых простых. Все узлы храним в массиве $nodes$, причем $i$-ым элементом этого массива, будет в свою очередь набор (список, лист) индексов узлов, которые непосредственно наследуются от $i$-го. Если $i$-ый узел -- лист (т.е. у него нет потомков), то храним в $nodes[i] = -1$ (можно хранить просто пустой массив). Во втором массиве \textit{edges} в $i$-ом элементе будет находиться метка ребра, которое ведет к $i$-му узлу. Нулевое значение (метка к корневому узлу) оставим путсым $edges[0] = ''$.

Пример такой структуры изображен на Рисунке 2.

\begin{figure}[H]
  \center{
  \includegraphics[scale = 0.85]{fig/fig2.jpg}
  }
  \caption{Пример массивов $nodes$ и $edges$ для дерева последовательности TTA\$.}
\end{figure}

Ниже приведен псевдокод создания этих двух массивов для строки $S$ (код в стиле Python, индексация массивов и строк с нулевого индекса, x[i:] все элементы с $i$-го \textit{включительно} до последнего, x[:i] -- все элементы с нулевого до $i$-го \textit{исключая}):

\clearpage
\begin{algorithmic}[1]
\Procedure{TreeCreation}{$S$}
\State $S = S + " \$ "$
\State $nodes \gets [[1], [-1]]$
\State $edges \gets [`` ``, S]$

\item[]
\For{$i\gets 1, len(S) - 1$}
\State $suf \gets S[i:]$
\State $j \gets 0$
\State $cur\_node \gets 0$
\State $isAdded \gets False$

\item[]
\While{not isAdded}
\State $to\_node \gets -1$

\For{$k \;\; in \;\;  nodes[cur\_node]$}
\If{$suf[j] == edges[k][0]$}
\State $to\_node \gets k$
\EndIf
\EndFor

\item[]

\If{$to\_node == -1$}
\State $nodes.append([-1])$ \Comment{Добавляем новый лист}
\State $edges.append(suf[j:])$  \Comment{Ребро к новому листу}
\State $nodes[cur\_node].append(len(nodes) - 1)$ \Comment{Ссылка на новый}
\State $isAdded \gets True$
\Else
\For{$p \gets 1, len(edges[to\_node]) - 1$}

\If{$suf[j + p] != edges[to\_node][p]$}
\State $nodes.append([-1])$ \Comment{Добавляем новый лист}
\State $edges.append(suf[j + p:])$ \Comment{Ребро к новому листу}
\State $nodes.append([to\_node, len(nodes) - 1])$ \Comment{Внутренний узел}
\State $edges.append(edges[to\_node][:p])$ \Comment{Ребрко к узлу}

\item[]
\item[] \Comment{Обновить ссылку из текущего на внутренний}
\State $nodes[cur\_node].remove(to\_node)$
\State $nodes[cur\_node].append(len(nodes) - 1)$ 

\State $edges[to\_node] = edges[to\_node][p:]$ \Comment{Обновить ребро}


\State $isAdded \gets True$
\State $break$
\EndIf

\EndFor

\State $j \gets j + len(edges[to\_node])$
\State $cur\_node = to\_node$

\EndIf

\EndWhile

\EndFor
\item[]
\State \Return $[nodes, edges]$
\EndProcedure
\end{algorithmic}


\clearpage
\section{Поиск в глубину}
\par
Решаем задачу поиска мотива, как посчитать количество вхождений? Допустим, мы ищем мотив $T$ в строке $S$, очевидно, что для каждого вхождения $T$ в $S$ будет существовать суффикс строки $S$, который начинается с $T$. Т.е. для каждого вхождения есть путь от корня суффиксного дерева к одному из листов, причем начинается этот путь со строки $T$. Количество вхождений -- это количество суффиксов, которые начинаются с $T$, а это в свою очередь количество листьев в дереве, пути к которым начинаются с $T$. Т.е. для нахождения мотива $T$, необходимо найти путь (если он существует, то он будет единственным) от корня дерева, который начинается с $T$, остановившись либо во внутреннем узле, либо в середине одного из ребер (возможна ситуация, когда мы остановимся и в листе дерева, \textit{подумайте, когда это может быть}). Чтобы определить количество вхождений, необходимо посчитать количество листьев потомков узла, на котором мы остановились или узла, от которого идет ребро, на котором мы остановились.

Задача подсчета количества листьев потомков одного из узлов ($i$-го узла) решается алгоритмом поиска в глубину, который достаточно просто реализуется через рекурсию:

\begin{algorithmic}[1]
\Procedure{LeavesCount}{$i$, $nodes$}
\If{$nodes[i][0] = -1$}
\State \Return $1$
\EndIf
\item[]
\State $lCount \gets 0$
\For{$k \;\; in \;\; nodes[i]$}
\State $lCount = lCount + LeavesCount(k, nodes)$
\EndFor
\item[]
\State \Return $lCount$
\EndProcedure
\end{algorithmic}

Для определения координат вхождения мотива $T$ в строку $S$ нам достаточно знать индексы (номера) листьев, которые являются потомками внутреннего узла, на котором мы остановились. Они же и будут являться координатами вхождения (1-ый суффикс -- соответствует первому символу, 2-ой -- второму и т.д.). Определение координат решается небольшой модернизацией вышеописанной рекурсивной функции.

\section{Какие еще задачи можно решить с помощью дерева}
\par
Поиск повтора, поиск максимальной общей подстроки, нечеткий поиск.

\section{Ссылки}

\begingroup
\renewcommand{\section}[2]{}%
\begin{thebibliography}{7}


\end{thebibliography}
\endgroup

\end{document}
