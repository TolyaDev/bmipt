\documentclass[letterpaper, 11pt]{article}

% set version variable
\newcommand{\versionnumber}{0.1}

% russian language
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english, russian]{babel}

% math
\usepackage{mathtools}
\usepackage{amsmath}

\usepackage{amssymb} % some math symbols
% abs function
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}

% set type and margins of the page
\usepackage{geometry}  % document margins
\geometry{letterpaper, left=1.4in, right = 1.4in, top = 1.7in, bottom = 1.7in}

% color links in content
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=red,
    urlcolor=blue,
    linktoc=all
}

% indent at first \par after section
\usepackage{indentfirst}

% fixed table and figures in section
\usepackage{float}

% colors
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}

% paragraph indent
\setlength{\parskip}{0.5em}

\title{\large{Краткий конспект}\\
\LARGE{Лекция 1. Поиск мотивов}\\
\normalsize версия \versionnumber (\textcolor{NavyBlue}{незавершенная})}
\date{11 февраля, 2016}
\author{Д. Ищенко\thanks{МФТИ} \and Б. Коварский\footnotemark[1]
\and И. Алтухов\footnotemark[1] \and Д. Алексеев\footnotemark[1]}

\begin{document}
\maketitle
\thispagestyle{empty}
\clearpage

% let's go
\section{Зачем искать мотивы?}
\section{Несколько слов о сложности алгоритмов}
\par
При разработке алгоритма важно представлять и оценивать кол-во времени 
необходимое для его исполнения при конкретных входных данных, а также объем компьютерных ресурсов,
задействованных при исполнении алгоритма. Когда мы говорим про <<конкретные данные>>, мы подразумеваем, 
определенную величину, например, размер памяти выделяемой под входные данные в битах. Будем называть эту
величину $n$. Для простоты будем считать, что время необходимое для исполнения алгоритма \textit{пропорционально}
кол-ву элементарных операций (которые в свою очередь определены архитектурой процессора). Будем считать
элементарными операциями: сложение, вычитание, умножение, деление, вычисление корня. Тогда оценка 
времени сводится к определению $f(n)$, функции количества элементарных операций от размера входных данных. Нас не будет 
интересовать точное значение $f(n)$ (это и не всегда возможно определить), а только лишь его оценка (чаще всего оценка сверху). Определяется она с помощью термина <<$O$ большое>> для ассимптотического поведения функций.
$f(n) = O(g(n))$ означает, что кол-во операций $f(n)$ при увеличении $n$ будет возрастать не быстрее, чем $g(n)$ умноженная на некоторую константу.
\[
\exists (C > 0), n_0 : \forall (n > n_0) \; f(n) \leq Cg(n)
\]
\par
Напрмер, сложность алгоритма который вычисляет простую сумму $k$ входных чисел $a_k$ оценивается, как $O(k)$. Грубо говоря, мы выполняем $(k-1)$ операций сложения. Таким образом кол-во операций $f(n)$ будет возрастать пропорционально кол-ву входных чисел $k$. Объем входных данных в битах можем оценить, как некоторую константу (например кол-во бит, зарезервированных под одно входящее число) умноженную на их кол-во $n = c \cdot k$, тогда $f(n) = f(c \cdot k) = k - 1 = O(k)$. Рассмотрим другой пример, алгоритм находящий ... \textcolor{red}{алгоритм $O(n^2)$} ...
\par
Аналогичные рассуждения в оценке применимы и к вычислению необходимой памяти (чаще оперативной) выделяемой
при исполнении алгоритма. Оценивается кол-во выделяемых бит $m(n)$ от размера входных данных и оценивается с помощью
$O(p(n))$. Возвращаясь к алгоритму вычисления суммы $k$ чисел $a_k$. Допустим, алгоритм построен следующим образом: (i) прочесть все $k$ чисел и записать в массив, (ii) просуммировать все $a_k$ и результат записать в $s$, (iii) выдать результат $s$. Задействованная оперативная память -- величина $m(n) = m(k \cdot c) = k \cdot c + c = c(k + 1) = O(k)$ (нам необходимо записать в массив все $k$ чисел, каждое из которых занимает $c$ бит, а также выделить память для перемнной $s$ размера $c$ бит). Если же изменить алгоритм следующим оразом: (i) объявляется переменная $s = 0$ для хранения суммы, (ii) по-очередно читается одно число из $a_k$ и добавляется к $s$, $s = s + a_k$, после чего $a_k$ удаляется из памяти (iii) выводится $s$. То в такой реализации нам необходимо хранить всего два значения $s$ и текующее $a_k$, а значит всего $2c$ бит. Другими словами, кол-во необходимой памяти \textit{не зависит} от размера входных данных (кол-ва входных чисел), такой вариант оцениватся, как $m(n) = 2c = O(1)$. При этом в обоих реализациях алгоритма оценка времени одинакова $f_1(n) = f_2(n) = O(k)$.
\par
Идеальным случаем ... \textcolor{red}{написать про $O(n)$} ...
\section{Простой подход к поиску мотива}
\par
Вернемся к задаче о поиске мотива. Есть строка (геном) $S$ и паттерн (мотив) $M$:
\begin{verbatim}
 S :  TATGCATGCATGA
 M :  ATGCTGA
\end{verbatim}
\par
Необходимо определить все позиции вхождения $M$ в $S$. Рассмотрим самый простой алгоритм, заключающийся в полном переборе всех позиций в $S$, подставления в них $M$ и проверки попарных совпадений символов (нуклеотидов).
\begin{verbatim}
 S :  TATGCATGCATGA
M1 :  ATGCATGA
      * 
M2     ATGCATGA
       +++++++*
M3      ATGCATGA
        *
M4       ATGCATGA
         *
M5        ATGCATGA
          *
M6         ATGCATGA
           ++++++++
\end{verbatim}
\par
Обозначаем символом <<*>> проверку на совпадение, которая вернула значения $FALSE$ (символы отличаются), а символом <<+>> проверку, вернувшую $TRUE$ (символы совпадают). Алгоритм можно описать следующим образом: двигаемся 
\section{Усовершенствование простого подхода}
\par
\begin{verbatim}
 S :  TATGCATGCATGA
M1 :  ATGCATGA
      * 
M2     ATGCATGA
       +++++++*
M3         ATGCATGA
           ++++++++
\end{verbatim}

\par
\begin{verbatim}
S  :  TATGCATGCATGA
M1 :  ATGCATGA
      * 
M2     ATGCATGA
       +++++++*
M3         ATGCATGA
              +++++
\end{verbatim}
\par
Вышеописанные подходы позволоили нам уменьшить количество сравнений. Но это был частный пример и рассуждали мы в <<свободной>> форме, а хочется это формализовать в виде алгоритма.
\section{Z-алгоритм}
\section{Ссылки}
\end{document}
